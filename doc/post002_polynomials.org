* polynomials
  This post is the first of a series of about polynomials.  I'm using
  it as a mean to explore the rust programming language while also
  learning math subjects.
  
  Polynomials are a fundamental mathematical entity used for a number
  of interesting applications including:
  - approximation of more complex functions
  - interpolation
  - error correction codes
  - graphical interpolation of curves (splines)

  I'm going to work with monovariate polynomials, i.e. polynomials of
  one variable only
** the structure
  a polynomial is completely defined by a string of values in a
  field. These represents the polynomial coefficient from the lowest
  to the highest grade (let's call it $n$); the highest grade
  coeddicient is supposed to be different from the zero of the field,
  and all coefficient of degree greather than $n$ are supposed to be
  zero.
  
  Main operation needed to define a polynomial are sum and
  multiplication thus it can be possible to use fields different from
  usual built-in types (integer and floating point numbers) as long as
  multiplication and sum are defined.

  Thus the data structure will contain a vector of values where sum
  and multiplication are defined. The vector is needed because we
  cannot know the length of the coefficient string in advance.

  At first I will add only a public constructor: coefficients should
  be immutable from the user perspective.
  #+name: poly0-struct
  #+begin_src rust
    #[derive(Debug)]
    pub struct Poly <T>{
        coeff : Vec<T>
    }

    impl<T> Poly<T>{
        pub fn new(coeff : Vec<T>) -> Poly<T>{
            Poly{ coeff:coeff }
        }
    }
  #+end_src

  I can also add a test to this file in order to make sure it is
  compiled properly. I will import Write in order to use a print debug
  and check all is ok
  #+name: poly0-test
  #+begin_src rust
        #[cfg(test)]
        mod tests {
            use super::Poly;
            #[test]
            fn creation_and_debug() {
                let x = Poly::new(vec![1,2,3]);
                assert_eq!(format!("{:?}", x), "Poly { coeff: [1, 2, 3] }");
            }
        }
  #+end_src
  #+begin_src rust :noweb tangle :tangle ../src/poly0.rs :exports none
    <<poly0-struct>>
    
    <<poly0-test>>
  #+end_src
** the basic operations
   I'd like to evaluate a polynomial in a point of its field. In order
   to do that I need the data to have the following properties:
   - sum is defined
   - multiplication is defined
   - there is a zero (neutral element of the sum)
   - the field values can be copied (i.e. there is a way to safely
     copy their binary representation)
  #+name: poly1-struct
  #+begin_src rust
    use std::ops::{Mul, Add};
    use std::fmt;

    #[derive(Debug)]
    pub struct Poly <T>{
        coeff : Vec<T>
    }

    impl<T: Mul<Output = T> + Add<Output = T> + Copy> Poly<T>{
        pub fn new(coeff : Vec<T>) -> Poly<T>{
            Poly{ coeff:coeff }
        }
        pub fn eval(self : &Poly<T>, x : T, zero : T) -> T {
            self.coeff.iter()
                .rev()
                .fold(zero, |acc, c| acc * x + *c)
        }
    }

    impl<T: fmt::Debug> fmt::Display for Poly<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let result : Vec<String> = self.coeff.iter()
                .enumerate()
                .map(|(i, c)| format!("({:?})^{}",c,i))
                .collect();
            write!(f, "{}", result.join(" + "))
        }
    }
  #+end_src

  let's check the current implementation works
  #+name: poly1-test
  #+begin_src rust
    #[test]
    fn test_evaluation() {
        let p = Poly::new(vec![1,2,3]);
        assert_eq!(p.eval(10,0), 321);
    }

    #[test]
    fn test_formatting() {
        let x = Poly::new(vec![1,2,3]);
        assert_eq!(format!("{}", x), "(1)^0 + (2)^1 + (3)^2");
    }
  #+end_src
  #+name poly1-test-display
  #+begin_src rust :exports none
    #[test]
    fn creation_and_debug() {
        let x = Poly::new(vec![1,2,3]);
        assert_eq!(format!("{:?}", x), "Poly { coeff: [1, 2, 3] }");
    }
  #+end_src
  #+begin_src rust :noweb tangle :tangle ../src/poly1.rs :exports none
    #[cfg(test)]
    mod tests {
        use super::Poly;
        <<poly1-test-display>>

        <<poly1-test>>
    }

    <<poly1-struct>>
  #+end_src
** a polynomial can be a function too
   Rust allows to use a data structure as a function by implementing
   some traits in the ~std::ops~ module:
   - ~Fn~ when the data structure is borrowed without mutability
   - ~FnMut~ when the data structure is borrowed with mutability
   - ~FnOne~ when the ownership is transferred to the data structure
   Please note: as for today (2022-1-1) the following code does not
   work on a stable release, so it is untested.

   We first have to enable some unstable feature
   #+name: poly2-prelude
   #+begin_src rust
     #![feature(unboxed_closures, fn_traits)]
   #+end_src

   Then we try to implement the trait
   #+name: poly2-function-implementation
   #+begin_src rust
     use std::ops::Fn;
     impl<T> Fn<(T, )> for Poly<T>{
         type Output = T;
         extern "rust-call" fn call(&self, args : (T,)){
             self.eval(args[0])
         }
     }
   #+end_src
  #+begin_src rust :noweb tangle :tangle ../src/poly2.rs :exports none
    #[cfg(test)]
    mod tests {
        use super::Poly;
        <<poly1-test-display>>

        <<poly1-test>>
    }

    <<poly1-struct>>

    <<poly2-function-implementation>>
  #+end_src
  #+begin_src rust :noweb tangle :tangle ../src/lib.rs :exports none
    pub mod poly0;
    pub mod poly1;
  #+end_src
